//	Sparse Voxel Octree pass compute shader
//	Each invocation of this shader traverses down
//	the sparse voxel octree, coloring the output
//	image
//
//	-

#version 440

layout(local_size_x = 1024) in;

#define OCTREE_LEFT_TOP_FRONT 0
#define OCTREE_RIGHT_TOP_FRONT 1
#define OCTREE_LEFT_TOP_BACK 2
#define OCTREE_RIGHT_TOP_BACK 3
#define OCTREE_LEFT_BOTTOM_FRONT 4
#define OCTREE_RIGHT_BOTTOM_FRONT 5
#define OCTREE_LEFT_BOTTOM_BACK 6
#define OCTREE_RIGHT_BOTTOM_BACK 7

const vec3 BASIS_X = vec3(1.0f, 0.0f, 0.0f);
const vec3 BASIS_Y = vec3(0.0f, 1.0f, 0.0f);
const vec3 BASIS_Z = vec3(0.0f, 0.0f, 1.0f);

const float EPSILON = 0.01f;

const uint UINT_MAX_LOG = 9;

struct OctreeNode {
	vec4 color;
	vec3 position;
	uint depth;
	int next;
};

uniform int root_node_offset;
uniform float root_node_size;

layout(std430, binding=1) readonly buffer octree_buffer {
	OctreeNode nodes[];
} OctreeBuffer;

struct RayState {
	vec3 ray;
	ivec2 pixel;
	int offset;
};

// Buffer for consuming
layout(std430, binding=2) readonly buffer pass_read_buffer {
	RayState read_state[];
} PassReadBuffer;

// Buffer for producing
layout(std430, binding=3) writeonly buffer pass_write_buffer {
	RayState write_state[];
} PassWriteBuffer;

struct PassMetaData {
	uint read_pass_size;
	uint write_pass_size;
};

// Buffer storing size of pass
// TODO: use atomic counters instead
layout(std430, binding=4) buffer meta_buffer {
	PassMetaData data;
} MetaBuffer;

layout(r32ui) uniform coherent uimage2D depth_image;
layout(r32i) uniform iimage2D out_image;

// Render pass control uniforms
uniform bool bootstrap;				// Flag to bootstrap initial pass, signals shader to shoot all rays at octree root
uniform bool finalize;				// Flag to finalize final pass, signals shader to generate result image

// Camera uniforms
uniform vec3 camera_position;		// Camera position, used as origin for rays
uniform vec3 camera_direction;
uniform float camera_near;
uniform float camera_far;
uniform float field_of_view;		// Field of view of camera in radians
uniform mat3 view;

// Render uniforms
uniform uvec2 render_resolution;	// Output render resolution

// Project vector u onto v
vec3 project(vec3 u, vec3 v) {
	return (dot(u, v) / dot(v, v)) * v;
}

vec3 cube_lower_bound(OctreeNode node, float size) {
	return node.position - (size / 2) * (BASIS_X + BASIS_Y + BASIS_Z);
}

vec3 cube_upper_bound(OctreeNode node, float size) {
	return node.position + (size / 2) * (BASIS_X + BASIS_Y + BASIS_Z);
}

// Returns true if cube bounded by lower and upper is hit by ray p + vt
bool raycast_cube(vec3 lower, vec3 upper, vec3 p, vec3 v) {
	float t0x = (lower.x - p.x) / v.x;
	float t0y = (lower.y - p.y) / v.y;
	float t0z = (lower.z - p.z) / v.z;
	float t1x = (upper.x - p.x) / v.x;
	float t1y = (upper.y - p.y) / v.y;
	float t1z = (upper.z - p.z) / v.z;
	float tlower = max(t0x, max(t0y, t0z));
	float tupper = min(t1x, min(t1y, t1z));
	return t0x < tupper &&
		t0y < tupper &&
		t0z < tupper &&
		t1x > tlower &&
		t1y > tlower &&
		t1z > tlower;
}

float log10(float x) {
	return log2(x) / log2(10.0f);
}

uint serialize_depth(float depth) {
	return uint(pow(10, UINT_MAX_LOG - (uint(log10(camera_far)) + 1)) * depth);
}

void main() {
	RayState state;

	OctreeNode root_node = OctreeBuffer.nodes[root_node_offset];
	OctreeNode current_node;
	float size;
	float depth;
	int offset;

	const float pixel_angle = field_of_view / render_resolution.x;

	if (gl_GlobalInvocationID.x >= MetaBuffer.data.read_pass_size) {
		return;
	}

	// Aquire ray state for ith iteration of pass
	state = PassReadBuffer.read_state[gl_GlobalInvocationID.x];
	offset = bootstrap ? root_node_offset : state.offset;
	state.ray = view * state.ray;

	current_node = OctreeBuffer.nodes[offset];
	size = root_node_size * pow(0.5f, current_node.depth - root_node.depth);
	depth = length(current_node.position - camera_position);
	float r = sin(pixel_angle) * length(current_node.position - camera_position);
	const bool ray_done =
		size < r ||
		current_node.color.a < EPSILON ||
		dot(camera_direction, current_node.position - camera_position) < camera_near - size ||
		depth > camera_far + size ||
		finalize;
	
	const bool hit = raycast_cube(cube_lower_bound(current_node, size), cube_upper_bound(current_node, size), camera_position, state.ray);
	const bool write = hit && !ray_done;

	uint previous_write_size = atomicAdd(MetaBuffer.data.write_pass_size, write ? 8 : 0);
	barrier();

	// NOTE: this flow diverges only when last ray is cast for pixel, not great but difficult to avoid
	if (write) {
		PassWriteBuffer.write_state[previous_write_size] = RayState(current_node.next, state.pixel, state.ray);
		PassWriteBuffer.write_state[previous_write_size + 1] = RayState(current_node.next + 1, state.pixel, state.ray);
		PassWriteBuffer.write_state[previous_write_size + 2] = RayState(current_node.next + 2, state.pixel, state.ray);
		PassWriteBuffer.write_state[previous_write_size + 3] = RayState(current_node.next + 3, state.pixel, state.ray);
		PassWriteBuffer.write_state[previous_write_size + 4] = RayState(current_node.next + 4, state.pixel, state.ray);
		PassWriteBuffer.write_state[previous_write_size + 5] = RayState(current_node.next + 5, state.pixel, state.ray);
		PassWriteBuffer.write_state[previous_write_size + 6] = RayState(current_node.next + 6, state.pixel, state.ray);
		PassWriteBuffer.write_state[previous_write_size + 7] = RayState(current_node.next + 7, state.pixel, state.ray);
		memoryBarrierBuffer();
	}
	
	uint initial_depth = serialize_depth(depth);

	imageStore(depth_image, ivec2(gl_GlobalInvocationID.x % render_resolution.x, gl_GlobalInvocationID.x / render_resolution.x), uvec4(gl_GlobalInvocationID.x));
	//barrier();
	
	if (ray_done && hit) {
		uint result_depth = 1234;//imageAtomicMin(depth_image, state.pixel, initial_depth);
		if (result_depth == initial_depth) {
			imageStore(out_image, state.pixel, ivec4(offset));
		}
	}
	barrier();
}
